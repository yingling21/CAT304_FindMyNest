"use strict";

import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport, lastAssistantMessageIsCompleteWithToolCalls } from "ai";
import { fetch as expoFetch } from "expo/fetch";
import { useCallback, useMemo } from "react";
import * as z from "zod/v4";
import { BASE_URL, withBaseUrl } from "./api.js";
import "./polyfills/fetch";
import { getPostHogClient } from "./analytics.js";
const AGENT_URL = withBaseUrl("/agent/chat");
export function createRorkTool(tool) {
  return tool;
}
// use generateObject and generate text only if you need a single generation.
// When the chat history and agentic flows are not needed
// For example, parsing image to text in mutation.
// or generating a caption for image, or a summary

export async function generateObject(params) {
  getPostHogClient()?.capture("RORK/GENERATE_OBJECT", {});
  const GENERATE_OBJECT_URL = new URL("/llm/object", BASE_URL).toString();
  const result = await fetch(GENERATE_OBJECT_URL, {
    method: "POST",
    body: JSON.stringify({
      messages: params.messages,
      schema: z.toJSONSchema(params.schema)
    })
  });
  const data = await result.json();
  return params.schema.parse(data.object);
}
export async function generateText(params) {
  getPostHogClient()?.capture("RORK/GENERATE_TEXT", {});
  const GENERATE_TEXT_URL = new URL("/llm/text", BASE_URL).toString();
  const messages = typeof params === "string" ? [{
    role: "user",
    content: params
  }] : params.messages;
  const result = await fetch(GENERATE_TEXT_URL, {
    method: "POST",
    body: JSON.stringify({
      messages
    })
  });
  const data = await result.json();
  return data.completion;
}
export function useRorkAgent(options) {
  const {
    addToolResult,
    ...rest
  } = useChat({
    ...options,
    sendAutomaticallyWhen: lastAssistantMessageIsCompleteWithToolCalls,
    transport: new DefaultChatTransport({
      fetch: expoFetch,
      api: AGENT_URL,
      body: () => {
        const toolsEntries = Object.entries(options.tools).map(([name, tool]) => [name, {
          description: tool.description,
          jsonSchema: z.toJSONSchema(tool.zodSchema)
        }]);
        return {
          tools: Object.fromEntries(toolsEntries)
        };
      }
    }),
    onToolCall: async ({
      toolCall
    }) => {
      getPostHogClient()?.capture("RORK/USE_AGENT/TOOL_CALL", {
        toolName: toolCall.toolName
      });
      const tool = options.tools[toolCall.toolName];
      if (!tool) {
        throw new Error(`Tool ${toolCall.dynamic} not found`);
      }
      if (!tool.execute) return;
      const result = await tool.execute(toolCall.input);
      addToolResult({
        toolCallId: toolCall.toolCallId,
        tool: toolCall.toolName,
        output: result
      });
    }
  });
  const messages = useMemo(() => {
    return rest.messages.map(m => {
      const parts = m.parts.map(p => {
        if (p.type === "text") return p;
        if (p.type.startsWith("tool")) {
          const toolPart = p;
          const toolName = toolPart.type.replace(/^tool-/, "");
          return {
            ...p,
            type: "tool",
            toolName
          };
        }
        return undefined;
      }).filter(p => p !== undefined);
      return {
        ...m,
        parts
      };
    });
  }, [rest.messages]);
  const sendMessage = useCallback(message => {
    getPostHogClient()?.capture("RORK/USE_AGENT/SEND_MESSAGE", {});
    if (typeof message === "string") {
      rest.sendMessage({
        text: message
      });
    } else {
      rest.sendMessage(message);
    }
  }, [rest]);
  return {
    ...rest,
    sendMessage,
    messages,
    addToolResult
  };
}
//# sourceMappingURL=agent.js.map