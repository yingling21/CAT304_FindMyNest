import { type UseChatOptions } from "@ai-sdk/react";
import { type UIMessage } from "ai";
import * as z from "zod/v4";
import "./polyfills/fetch";
type Tool<T extends z.ZodType = z.ZodType> = {
    description: string;
    zodSchema: T;
    execute?: (input: z.infer<T>) => Promise<string> | string;
};
export declare function createRorkTool<T extends z.ZodType>(tool: Tool<T>): Tool<T>;
type TextPart = {
    type: "text";
    text: string;
};
type ImagePart = {
    type: "image";
    image: string;
};
type UserMessage = {
    role: "user";
    content: string | (TextPart | ImagePart)[];
};
type AssistantMessage = {
    role: "assistant";
    content: string | TextPart[];
};
export declare function generateObject<T extends z.ZodType>(params: {
    messages: (UserMessage | AssistantMessage)[];
    schema: T;
}): Promise<z.infer<T>>;
export declare function generateText(params: string | {
    messages: (UserMessage | AssistantMessage)[];
}): Promise<string>;
export declare function useRorkAgent<T extends Record<string, Tool<z.ZodType>>>(options: Omit<UseChatOptions<UIMessage>, "transport"> & {
    tools: T;
}): {
    sendMessage: (message: string | Parameters<(message?: (Omit<UIMessage<unknown, import("ai").UIDataTypes, import("ai").UITools>, "id" | "role"> & {
        id?: string | undefined;
        role?: "user" | "assistant" | "system" | undefined;
    } & {
        text?: never;
        files?: never;
        messageId?: string;
    }) | {
        text: string;
        files?: FileList | import("ai").FileUIPart[];
        metadata?: unknown;
        parts?: never;
        messageId?: string;
    } | {
        files: FileList | import("ai").FileUIPart[];
        metadata?: unknown;
        parts?: never;
        messageId?: string;
    } | undefined, options?: import("ai").ChatRequestOptions) => Promise<void>>[0]) => void;
    messages: {
        parts: (import("ai").TextUIPart | {
            type: "tool";
            toolName: string;
            toolCallId: string;
            providerExecuted?: boolean;
            state: "input-streaming";
            input: unknown;
            output?: never;
            errorText?: never;
        } | {
            type: "tool";
            toolName: string;
            toolCallId: string;
            providerExecuted?: boolean;
            state: "input-available";
            input: unknown;
            output?: never;
            errorText?: never;
            callProviderMetadata?: import("ai").ProviderMetadata;
        } | {
            type: "tool";
            toolName: string;
            toolCallId: string;
            providerExecuted?: boolean;
            state: "output-available";
            input: unknown;
            output: unknown;
            errorText?: never;
            callProviderMetadata?: import("ai").ProviderMetadata;
            preliminary?: boolean;
        } | {
            type: "tool";
            toolName: string;
            toolCallId: string;
            providerExecuted?: boolean;
            state: "output-error";
            input: unknown;
            rawInput?: unknown;
            output?: never;
            errorText: string;
            callProviderMetadata?: import("ai").ProviderMetadata;
        })[];
        id: string;
        role: "system" | "user" | "assistant";
        metadata?: unknown;
    }[];
    addToolResult: <TOOL extends string>({ state, tool, toolCallId, output, errorText, }: {
        state?: "output-available";
        tool: TOOL;
        toolCallId: string;
        output: unknown;
        errorText?: never;
    } | {
        state: "output-error";
        tool: TOOL;
        toolCallId: string;
        output?: never;
        errorText: string;
    }) => Promise<void>;
    id: string;
    setMessages: (messages: UIMessage<unknown, import("ai").UIDataTypes, import("ai").UITools>[] | ((messages: UIMessage<unknown, import("ai").UIDataTypes, import("ai").UITools>[]) => UIMessage<unknown, import("ai").UIDataTypes, import("ai").UITools>[])) => void;
    error: Error | undefined;
    stop: () => Promise<void>;
    status: import("ai").ChatStatus;
    regenerate: ({ messageId, ...options }?: {
        messageId?: string;
    } & import("ai").ChatRequestOptions) => Promise<void>;
    resumeStream: (options?: import("ai").ChatRequestOptions) => Promise<void>;
    addToolOutput: <TOOL extends string>({ state, tool, toolCallId, output, errorText, }: {
        state?: "output-available";
        tool: TOOL;
        toolCallId: string;
        output: unknown;
        errorText?: never;
    } | {
        state: "output-error";
        tool: TOOL;
        toolCallId: string;
        output?: never;
        errorText: string;
    }) => Promise<void>;
    clearError: () => void;
};
export {};
//# sourceMappingURL=agent.d.ts.map